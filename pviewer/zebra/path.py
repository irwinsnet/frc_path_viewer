"""Classes that represent FRC robot path and match data.

Module Contents:
    Match: A class that contains all data for a single FRC match.
    Competitions: A composite class that contains multile Match objects
    for one or more competitions.

Stacy Irwin, 16 Aug 2021.
"""

import json
import pickle

import numpy as np
import pandas as pd


class Match():
    """Zebra path data and detailed scores for a single FRC match.

    Attributes:
        event: The TBA event key that identifies the competition, such
               as '2020wasno'.
        match: The TBA match key that ientifies the match, such as
               '2020wasno_1sf1'.
        blue: A list containing the three blue alliance team keys, i.e.,
             ['frc1318', 'frc2976', 'frc4131'].
        red: A list containing the three red alliance team keys.
        paths:  * A numpy array with shape (12, path_length). The tracking
                system records 10 positions per second and matches are
                150 seconds long, so the path_length is a bit longer
                than 1500, typically 1503 or 1504, etc.
                * Up to six different robots compete in an FRC match.
                The path data is stored as a Numpy array with 12 rows,
                two rows (x and y coordinates) for each robot in the
                match. If a robot did participate or tracking data is
                missing, the corresponding row will be filled with
                Numpy nan values.
        times: A Numpy array of length path_length, containing the
               elapsed time in seconds since the commencement of robot
               tracking.
        score:  A JSON object containing detailed score data for the
                match, exactly as downloaded from TBA.
        teams: A dictionary object to simplify data access. The keys
              are the six TBA team keys, with the values also being
              dictionaries, structured as so:
              ```
              {'xs': Numpy array containing x coordinates,
               'ys': Numpy array containing y coordinates,
               'station': Alliance station name.,
               'start': robot starting position,
               'end': robot ending position,
               'n': Number of non-missing positions in Numpy array,
               'missing': Number of missing positions in Numpy array}
              ```

    Constructor Args:
        match_text: A single line of JSON text from the data file
            generated by the `zebra.download_data()` function. The JSON
            text consists of a dictionary with four keys: 'event',
            'match', 'zebra', and 'score'.
    """
    def __init__(self, match_json):
        if isinstance(match_json, str):
            match_json = json.loads(match_json)
        self.event = match_json['event']
        self.match = match_json['match']
        self.blue = [team['team_key']
                     for team in match_json['zebra']['alliances']['blue']]
        self.red = [team['team_key']
                    for team in match_json['zebra']['alliances']['red']]
        paths = []
        for alliance in ['blue', 'red']:
            for team in match_json['zebra']['alliances'][alliance]:
                for axis in ['xs', 'ys']:
                    paths.append(team[axis])
        self.paths = np.array(paths)
        self.times = np.array(match_json['zebra']['times'])
        self.score = match_json['score']
        
        teams_list = self.blue + self.red
        stations = ['blue1', 'blue2', 'blue3', 'red1', 'red2', 'red3']
        self.teams = {}
        for idx, tm in enumerate(teams_list):
            x_path_idx = 2*idx
            y_path_idx = 2*idx + 1
            team_data = self._scan_path(self.paths[x_path_idx],
                                        self.paths[y_path_idx])
            team_data['xs'] = self.paths[x_path_idx]
            team_data['ys'] = self.paths[y_path_idx]
            team_data['station'] = stations[idx]
            self.teams[tm] = team_data

    @staticmethod
    def _scan_path(xs, ys):
        """Scans path for start and end positions and missing coordinates."""
        if all([x is None for x in xs]) and all([y is None for y in ys]):
            return {'start': None, 'end': None, 'n': 0, 'missing': None}
        
        missing_coords = []
        for t, coords in enumerate(zip(xs, ys)):
            if coords[0] is None or coords[1] is None:
                missing_coords.append(t)
        
        for t, coords, in enumerate(zip(xs, ys)):
            if coords[0] is not None and coords[1] is not None:
                start = (coords[0], coords[1], t)
                break
        for t, coords, in enumerate(zip(np.flip(xs), np.flip(ys))):
            if coords[0] is not None and coords[1] is not None:
                end = (coords[0], coords[1], len(xs) - t)
                break
                
        return {'start': start,
                'end': end,
                'n': len(xs) - len(missing_coords),
                'missing': missing_coords}
                

class Competitions():
    """Zebra position data and scores for one or more FRC competitions.

    A `zebra.Competitions` object contains `zebra.Match` objects for
    one or more competitions. Use standard Python indexing notation
    (i.e., square brackets) to access individual `zebra.Match` object.
    The index value can be a positive integer or a Blue Alliance match
    key.
    For example:
        ```
        zc = zebra.Competitions('data_file.jsonl')
        zmatch1 = zc['2020wasno_qm1']

        num_matches = len(zc)
        zmatch2 = zc[num_matches - 1]
        ```
    """
    def __init__(self, file):
        """Initializes a zebra.Competitions object.

        The Competitions object is initialized from a JSONL text file
        produced by the `zebra.download()` function. See the
        documentation for `zebra.download()` for additional information
        on the format of the JSONL file.

        Args:
            file: String containing path to zebra position data. The
            file path should be suitable for Python's built-in `open()`
            function.
        """
        self.event_summary = None
        self.zmatches = None
        self._read_file(file)
        self.mindex = {zm.match: idx for idx, zm in enumerate(self.zmatches)}
        self.events = list(set([zmatch.event for zmatch in self.zmatches]))
        
    def __getitem__(self, idx):
        """Retrieves Match object from integer or TBA match key."""
        if isinstance(idx, int):
            return self.zmatches[idx]
        else:
            return self.zmatches[self.mindex[idx]]
    
    def __len__(self):
        """Returns number of matches in Competitions object."""
        return len(self.zmatches)
    
    def _read_file(self, file):
        """Reads data from JSONL source file."""
        # Convert file data to JSON, assumes file not too big for memory.
        with open(file) as jlfile:
            self.paths = [json.loads(line) for line in jlfile]
        
        # Create Event Summary DF, shows all events checked for zebra data
        events = [path['event'] for path in self.paths]
        matches = [path['match'] for path in self.paths]
        zebra = [ 0 if path['zebra'] is None else 1 for path in self.paths]
        self.event_summary = (
            pd.DataFrame({'event': events, 'match': matches, 'path': zebra})
            .groupby('event')
            .agg(path_matches=('path', 'sum'))
        )
        
        # Remove matches with no Zebra path data
        self.zmatches = [Match(path) for path in self.paths
                        if path['zebra'] is not None]

    def matches(self, event):
        """Gets list of matches as TBA match keys for a specific event."""
        return [zmatch.match for zmatch in self.zmatches
                if zmatch.event == event]
